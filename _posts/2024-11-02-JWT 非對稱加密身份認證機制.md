---
layout: post
title: "JWT 非對稱加密身份認證機制"
date: 2024-11-02
categories: [Backend, Security]
tags: [JWT, Authentication, Cryptography, Microservices]
author: Allen Liao
---

## 前言

在開發後端服務時，身份認證是不可或缺的一環。JWT (JSON Web Token) 搭配非對稱加密是目前主流的解決方案之一，但初次接觸時很容易對「公鑰私鑰該放哪？」、「誰該持有什麼金鑰？」這些問題感到困惑。

這篇筆記會用生活化的例子，幫助你（未來的自己）快速理解 JWT 非對稱加密的運作原理。

## 概念說明

### 什麼是非對稱加密？

想像一下郵局的掛號信系統：

- **私鑰** 就像郵局的專屬印章，只有郵局擁有，絕不外借
- **公鑰** 就像驗證印章真偽的樣本手冊，每個收件單位都可以有一份

**重點來了**：即使大家都有樣本手冊（公鑰），也無法偽造出郵局的印章（私鑰）來蓋假章。但拿著樣本手冊，就能確認「這個章確實是郵局蓋的」。

### 金鑰配置

#### 私鑰 (Private Key)

- **存放位置**：只在 User Service（認證服務）
- **保密等級**：最高機密，絕對不能外流
- **用途**：簽署 JWT Token

#### 公鑰 (Public Key)

- **存放位置**：所有需要驗證 JWT 的服務
- **保密等級**：可公開分享
- **用途**：驗證 JWT 簽章的真實性

> 💡 **觀念釐清**：公鑰是可以（也應該）公開的！這不是安全漏洞，而是非對稱加密的核心設計。

## 運作流程

### 步驟一：用戶登入取得 JWT

```
1. 用戶輸入帳號密碼
   ↓
2. User Service 驗證身份
   ↓
3. 驗證通過後，用私鑰簽署 JWT
   ↓
4. 返回 JWT 給 Client
   ↓
5. Client 儲存 JWT（通常存在 localStorage 或 cookie）
```

這就像你去市政府辦身份證，市政府（User Service）用他們的專屬印章（私鑰）在你的證件上蓋章，然後把證件交給你。

### 步驟二：使用 JWT 訪問其他服務

```
1. Client 帶著 JWT 訪問 Order Service
   ↓
2. Order Service 用公鑰驗證 JWT 簽章
   ↓
3. 驗證通過，確認這是 User Service 簽發的
   ↓
4. 信任 JWT 內的用戶資訊，處理請求
   ↓
5. 返回訂單資料給 Client
```

這就像你拿著蓋好章的身份證去銀行辦事，銀行員工（Order Service）對照印章樣本（公鑰）確認「這確實是市政府發的證件」，就讓你辦理業務，不需要每次都打電話回市政府確認。

## 實際應用場景

假設你在開發一個電商平台的微服務架構：

```
┌──────────────────────────┐
│   User Service - 認證中心   │
│   - 持有私鑰                │
│   - 負責用戶登入驗證          │
│   - 簽發 JWT Token          │
└────────────┬─────────────┘
             │
             │ 分發公鑰
             ↓
    ┌────────────────────┐
    │  各服務持有公鑰       │
    │  獨立驗證 JWT        │
    └────────┬───────────┘
             │
    ┌────────┴─────────┬─────────────┬──────────────┐
    ↓                  ↓             ↓              ↓
[Order Service]  [Payment Service]  [Shipping]  [Product]
 查詢訂單、建立訂單     處理金流         安排物流      商品資訊
```

### 這樣設計的好處

1. **降低服務耦合**
   各服務不需要一直回 User Service 詢問「這個 Token 是真的嗎？」，自己就能驗證。

2. **提升系統效能**
   本地驗證比遠端 API 呼叫快得多，減少網路延遲。

3. **提高可用性**
   即使 User Service 暫時掛掉，其他服務仍能用公鑰驗證 JWT，繼續運作。

4. **水平擴展容易**
   新增服務時，只要拿到公鑰就能加入驗證機制，不需要改動現有服務。

## 程式碼範例

### 簽發 JWT (User Service)

```go
// 使用 Golang + jwt-go 套件
import "github.com/golang-jwt/jwt/v5"

func GenerateJWT(userID string) (string, error) {
    // 讀取私鑰
    privateKey, err := jwt.ParseRSAPrivateKeyFromPEM(privateKeyBytes)
    if err != nil {
        return "", err
    }

    // 建立 Claims
    claims := jwt.MapClaims{
        "sub": userID,                             // 用戶 ID
        "exp": time.Now().Add(24 * time.Hour).Unix(), // 過期時間
        "iat": time.Now().Unix(),                  // 簽發時間
        "roles": []string{"user"},                 // 用戶角色
    }

    // 用私鑰簽署
    token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
    return token.SignedString(privateKey)
}
```

### 驗證 JWT (其他 Services)

```go
func VerifyJWT(tokenString string) (*jwt.Token, error) {
    // 讀取公鑰
    publicKey, err := jwt.ParseRSAPublicKeyFromPEM(publicKeyBytes)
    if err != nil {
        return nil, err
    }

    // 用公鑰驗證
    token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
        // 確認簽署方法
        if _, ok := token.Method.(*jwt.SigningMethodRSA); !ok {
            return nil, fmt.Errorf("unexpected signing method")
        }
        return publicKey, nil
    })

    return token, err
}
```

## 安全實作建議

### 私鑰管理

```bash
# ❌ 千萬不要這樣做
# 把私鑰寫死在程式碼裡
# 把私鑰 commit 到 Git

# ✅ 正確做法
# 1. 存在環境變數
export PRIVATE_KEY="..."

# 2. 使用密鑰管理系統
# - AWS Secrets Manager
# - Google Cloud Secret Manager
# - HashiCorp Vault

# 3. 定期輪換私鑰
# 建議每 3-6 個月更換一次
```

### 公鑰分發方式

**方法一：透過 API Endpoint**

```
GET https://auth-service.com/.well-known/jwks.json
```

**方法二：寫在配置檔**

```yaml
# config.yaml
jwt:
  public_key: |
    -----BEGIN PUBLIC KEY-----
    MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...
    -----END PUBLIC KEY-----
```

**方法三：使用 Kubernetes ConfigMap/Secret**

```bash
kubectl create configmap jwt-public-key --from-file=public.pem
```

### JWT 內容設計

```json
{
  "sub": "user_12345",           // Subject: 用戶唯一識別碼
  "exp": 1700000000,             // Expiry: 過期時間 (Unix timestamp)
  "iat": 1699990000,             // Issued At: 簽發時間
  "iss": "auth-service",         // Issuer: 簽發者
  "aud": ["order", "payment"],   // Audience: 目標服務
  "roles": ["user", "premium"],  // 自定義：用戶角色
  "email": "user@example.com"    // 自定義：常用資訊
}
```

> ⚠️ **注意**：JWT 內容是 Base64 編碼，不是加密！任何人都能解碼看到內容，所以不要放敏感資訊（如密碼、信用卡號）。

## 常見問題

### Q1: 如果私鑰外洩怎麼辦？

立即執行以下步驟：

1. 生成新的金鑰對
2. 更新 User Service 的私鑰
3. 分發新公鑰給所有服務
4. 讓所有舊 JWT 失效（可透過黑名單機制）

### Q2: JWT 過期時間該設多長？

依據使用情境：

- **短期 Access Token**：15 分鐘 ~ 1 小時
- **長期 Refresh Token**：7 天 ~ 30 天
- **記住我功能**：30 天 ~ 90 天

建議使用 Access Token + Refresh Token 雙 Token 機制。

### Q3: 能撤銷特定 JWT 嗎？

JWT 本身是無狀態的，無法撤銷。解決方案：

1. 維護黑名單（Redis）
2. 縮短過期時間
3. 加入版本號，批次撤銷

## 總結

JWT 非對稱加密的核心觀念：

- **私鑰簽署**：只有認證服務能做，證明「這是我發的」
- **公鑰驗證**：所有服務都能做，確認「這確實是認證服務發的」
- **公鑰可公開**：這不是弱點，而是設計特性

記住這個類比：**私鑰是郵局的專屬印章，公鑰是驗證手冊**。即使手冊人人都有，也無法偽造印章，但能用手冊驗證章的真偽。

## 參考資源

- [JWT.io](https://jwt.io) - JWT 標準與除錯工具
- [RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519) - JWT 官方規範
- [OWASP JWT Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html) - 安全最佳實踐
